# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# The overview topology of the whole application cluster or services,
type MetricResult {
    sla: IntValues
    nodeCpm: IntValues
    nodeLatency: IntValues
    cpmS: IntValues
    latencyS: IntValues
    cpmC: IntValues
    latencyC: IntValues
}

type Topology {
    nodes: [Node!]!
    calls: [Call!]!
    metricResult: MetricResult
}

# Node in Topology
type Node {
    # The global id of each node,
    # 1. Service id
    # 2. Endpoint id
    id: ID!
    # The literal name of the #id.
    name: String!
    userDefName: String
    # The type name may be
    # 1. The service provider/middleware tech, such as: Tomcat, SpringMVC
    # 2. Conjectural Service, e.g. MySQL, Redis, Kafka
    type: String
    userDefNodeType: String
    # It is a conjuncture node or real node, to represent a service or endpoint.
    isReal: Boolean!

    tenantId: String
    applicationSystemId: String
    bsId: String
    tsId: String
    nodeId: String
    host: String
    ciId: String
}

# The Call represents a directed distributed call,
# from the `source` to the `target`.
type Call {
    source: ID!
    # The protocol and tech stack used at source side in this distributed call
    sourceComponents: [ID!]!
    target: ID!
    # The protocol and tech stack used at target side in this distributed call
    targetComponents: [ID!]!
    id: ID!
    # The detect Points of this distributed call.
    detectPoints: [DetectPoint!]!
}

enum NodeType {
    SERVICE,
    ENDPOINT,
    USER
}


extend type Query {
    # Query the global topology
    getGlobalTopology(tenantId: String, bsIds: String,tsIds: String, duration: Duration!): Topology
    getTopologyWrappedByBs(tenantId: String, bsIds: String, duration: Duration!): Topology
    getTopologyWrappedByTs(tenantId: String, bsIds: String, duration: Duration!): Topology
    # Query the topology, based on the given service
    getServiceTopology(serviceId: ID!, duration: Duration!): Topology
    # Query the topology, based on the given endpoint
    getEndpointTopology(endpointId: ID!, duration: Duration!): Topology
    # get ciTopology
    getServicesTopology(serviceIds: [Int!]! , duration: Duration!): Topology
}